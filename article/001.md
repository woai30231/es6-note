我们在使用es6进行编程的过程中，经常出现编写函数需要传递参数默认值的情况。这其中又以对象默认传参用的最多，个人认为在函数中使用对象默认值参数有以下较明显的好处：

* 可以减少函数编写过程形参的个数，便于维护函数代码；

* 可以使用解构语法，很容易拿到对象参数里面对应的属性值；

* 有助于归类相关参数，提高可读性；

* 有助于将来函数的扩展，因为你可以给对象扩展很多属性，后续代码中，你可以通过读取相关属性值，就可以拿到所传参数。

我们先来通过一个简单的例子，来认识一下函数默认对象传参：

```javascript
  //es6
  function student(person){
    //解构相关参数值
    let {name,age} = person;
    console.log(name);//'小明'
    console.log(age);//15
  };
  
  student({name:'小明',age:15});
```
如果用es5来实现上面的功能，代码如下：

```javasript
  //es5
  function student(name,age){
    var name = name;
    var age = age;
    console.log(name);//'小明'
    console.log(age);//15
  };
  student('小明',15);
```

我们通过对比两种方法，可以明显看出es6的这种方法有如下：

- 参数少;

- 拿到相关参数值，更快捷、更方便;

- 含义是不是更形象、关联系更强？

当然了，实际应用中还有很多其它好处，可以自行google相关文档查看！

本文主要是说明，我们在使用对象默认参数编码过程中一些容易出现小错误的地方，我刚开始使用的时候，也是会经常弄错，本文就是把这些容易出错的地方找出来，并说明一下如何避免!

直接从一个代码例子说起吧，会足以说明每一步会遇到的问题。代码如下：

```javascript
  function student({name='xiaoming',age=15}){
     let {name,age} = {name,age};
     console.log(name);
     console.log(age);
  };
  student();//我们期望分别打印name,age
``` 

但是我们发现上面的代码报错了，如：


<pre style="color:#c00;">
  Uncaught SyntaxError: Identifier 'name' has already been declared
    at <anonymous>:6:3
</pre>

从上面提示我们可以看到name变量重复定义了，为什么呢？因为在用解构进行赋值的过程中，解构出现了跟es6中使用let、const定义变量一样出现“暂时性死区”、“变量不能重新定义”等问题！我们看一下其中一个代码片段：

```javascript
  let {name,age} = {name,age};
```
我们发现其实等号两边都同时进行了解构赋值，并且标记符使用了标记符let，我们知道在es6中，使用let进行定义的变量，在作用域块内不能重新定义，否则会报重复定义变量错误，上面的变量等价于：

```javascript
  let {name,age};
  let {name,age};
  //进行了两次声明
```
更形象地上面的代码，最终等价于下面的代码：

```javascript
  let name;
  let age;
  let name;
  let age;
```

那怎么解决呢？其实有多种方法，我们先来看法1：

```javascript
  //使用var进行声明
  //var允许变量重复定义
  function student({name='xiaoming',age=15}){
     var {name,age} = {name,age};
     console.log(name);
     console.log(age);
  };
  student();//我们期望分别打印name,age
```

再来看看法2：

```javascript
  //既然我们多写了一下，那为什么不少写一次呢？
  //但是函数形参要改变一下
  function student(person){
     let {name,age} = person;
     console.log(name);
     console.log(age);
  };
  student();//我们期望分别打印name,age
```

虽然经过这样改动之后，不报重复定义变量的错误了，但是还是报错，我们来看一下错误信息：

<pre>
  Uncaught TypeError: Cannot destructure property `name` of 'undefined' or 'null'.
    at student (<anonymous>:2:23)
    at <anonymous>:6:3
</pre>

很明显，错误信息提示我们不能从undefined和null中解构。因为我们在调用student函数的时候我们没有传实参，导致第一个参数是undefined,因此报错。要想解决这错误，我们根据提示就知道，只要保证第一个参数不是undefined或null就不会报错了，于是我们作如下修改：

```javascript
  function student(person={}){
     let {name,age} = person;
     console.log(name);
     console.log(age);
  };
  student();//我们期望分别打印name,age
```
虽然现在我们的代码调用不会报错了，但是发现name,age打印出来都是undefined。这是因为我们虽然保证了第一个形参不是undefined或null，但是它是一个空对象，所以我们解构赋值的时候，得到其对应的name和age属性都是undefined，所以最后打印undefined了。怎么解决呢！好嘛，那我们一步一步来写，其实我们只要保证第一个形参不但不是undefined或者null，并且相应的属性值是对应的默认值就可以了，如此我们继续来写代码：

```javascript
  function student(person={name:'xiaoming',age:15}){
     let {name,age} = person;
     console.log(name);
     console.log(age);
  };
  student();//我们期望分别打印name,age
```



